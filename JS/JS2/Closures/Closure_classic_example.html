<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>
    //  ------------- Разбор поведения функций при замыкании --------------------

    //
   function make() {
       // debugger;
       var count = 1;

       return function() {
           var a = 0;
           // debugger;
           return count++ // при вызове ниже создается аналогичная скрытая переменная внутри анонимной функции, Scope - Closure - count
       }
   }

   var counter1 = make();

                               // Итоговым значением, записанным в переменную counter, является внутренняя функция:
                               // function() { // [[Scope]] -> {currentCount: 1}
                               //     return currentCount++;
                               // };
                               // Присвоили, то что вернула функция make(),
                               // (функция - это тоже данные)

                            // только ниже внутренняя функция начнёт выполнятся
   console.log(counter1()); // здесь создастся объект Lexical Environment co всеми переменными анонимной функции,
                            // а также скрытой копией count - "currentCount"
                            // из-за того что переменная ссылается на внешнюю, сборщик мусора не удалит объект LE,
   console.log(counter1()); // и при вызове функции ещё раз мы будем вновь работать со старым LE
                            // и уже той же скрытой переменной будет присвоенно новое +1 значение
   console.log(counter1());
                            // переменная count =1 которая находится в make() так и остается равной 1.
                            // И когда мы создаём новую переменную-функцию(внутреннюю)
   var counter2 = make();   // создается новый Scope, который также остается в памяти(из-за 'замыкания' на внешнюю переменную count из make()), независимо от counter1

   console.log(counter2()); // соответственно включается новый скрытый счетчик count


</script>
</body>
</html>